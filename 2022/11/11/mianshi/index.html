<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>mianshi · Steve Gao's 自留地</title><meta name="description" content="css如何让一个盒子在水平方向和垂直方向都居中1.flex 盒子
2.父盒子 position：relative定位，子盒子绝对定位 translate(-50%,-50%)
less或者sass相比于css有什么优势？1.嵌套
2.定义变量
3.可以通过宏（mixin）抽取公共样式
如何做响应式布"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Steve Gao's 自留地</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>mianshi</a></h3></div><div class="post-content"><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h6 id="如何让一个盒子在水平方向和垂直方向都居中"><a href="#如何让一个盒子在水平方向和垂直方向都居中" class="headerlink" title="如何让一个盒子在水平方向和垂直方向都居中"></a>如何让一个盒子在水平方向和垂直方向都居中</h6><p>1.flex 盒子</p>
<p>2.父盒子 position：relative定位，子盒子绝对定位 translate(-50%,-50%)</p>
<h6 id="less或者sass相比于css有什么优势？"><a href="#less或者sass相比于css有什么优势？" class="headerlink" title="less或者sass相比于css有什么优势？"></a>less或者sass相比于css有什么优势？</h6><p>1.嵌套</p>
<p>2.定义变量</p>
<p>3.可以通过宏（mixin）抽取公共样式</p>
<h6 id="如何做响应式布局或者如何适配"><a href="#如何做响应式布局或者如何适配" class="headerlink" title="如何做响应式布局或者如何适配"></a>如何做响应式布局或者如何适配</h6><p>1.flex</p>
<p>2.百分比布局</p>
<p>3.rem</p>
<p>4.媒体查询</p>
<p>5.rpx</p>
<h6 id="css-sprite-雪碧图或者精灵图-有什么优缺点？"><a href="#css-sprite-雪碧图或者精灵图-有什么优缺点？" class="headerlink" title="css sprite(雪碧图或者精灵图) 有什么优缺点？"></a>css sprite(雪碧图或者精灵图) 有什么优缺点？</h6><p>优点</p>
<p>1.减少 HTTP 请求</p>
<p>缺点</p>
<p>1.维护变差</p>
<h6 id="你知道哪些css3新特性和h5新特性"><a href="#你知道哪些css3新特性和h5新特性" class="headerlink" title="你知道哪些css3新特性和h5新特性"></a>你知道哪些css3新特性和h5新特性</h6><p>1.background-position</p>
<p>2.border-radius</p>
<p>3.flex</p>
<p>4.text-shadow</p>
<p>5.transform:</p>
<p>HTML 5 新特性</p>
<p>1.语义化标签</p>
<p>2.localStorage（本地存储）</p>
<p>3.websocket</p>
<h6 id="rgba-和opacity的透明效果有什么不同"><a href="#rgba-和opacity的透明效果有什么不同" class="headerlink" title="rgba()和opacity的透明效果有什么不同"></a>rgba()和opacity的透明效果有什么不同</h6><p>​		rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元 </p>
<p>素内的所有内容的透明度， </p>
<p>⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承 </p>
<p>透明效果！）</p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h6 id="js数据类型有哪些？有什么区别"><a href="#js数据类型有哪些？有什么区别" class="headerlink" title="js数据类型有哪些？有什么区别"></a>js数据类型有哪些？有什么区别</h6><p>基本数据类型</p>
<p>string，number，bigint，boolean，null，undefined，symbol (ECMAScript 2016 新增)</p>
<p>引用数据类型</p>
<p>object</p>
<p>区别？</p>
<p>基本数据类型放到栈里面</p>
<p>引用类型堆和栈都有存储，堆里面放本体，栈里面放存储地址</p>
<h6 id="谈一下你对作用域的理解"><a href="#谈一下你对作用域的理解" class="headerlink" title="谈一下你对作用域的理解"></a>谈一下你对作用域的理解</h6><p>1.标识符（变量和函数）能够访问的范围</p>
<p>2.全局</p>
<p>3.局部（函数）</p>
<p>4.块级</p>
<p>作用域链</p>
<p>变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p>
<h6 id="谈一下你对原型的理解"><a href="#谈一下你对原型的理解" class="headerlink" title="谈一下你对原型的理解"></a>谈一下你对原型的理解</h6><p><strong>proto</strong> 指向构造函数的原型对象</p>
<p>每个函数都有一个原型对象 prototype（显示原型）</p>
<p>原型链：查找对象属性的查找路径就是原型链</p>
<p>当访问一个对象的属性时， 会在这个对象的属性上去找，如果没有找到就会去这个对象的–proto– 上去找，即构造函数prototype 上找，如果没有会一直在–proto– 上找，直到最顶层，不到即为undefined 。这样一层一层地向上，就彷佛一条链子串起来，所以就叫原型链。</p>
<h6 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h6><p>能够访问其他局部作用域中的变量的函数称之为闭包</p>
<h6 id="如何修改函数的this指向，这些方法之间有什么区别？"><a href="#如何修改函数的this指向，这些方法之间有什么区别？" class="headerlink" title="如何修改函数的this指向，这些方法之间有什么区别？"></a>如何修改函数的this指向，这些方法之间有什么区别？</h6><p>1.call</p>
<p>2.apply</p>
<p>3.bind</p>
<p>前两个立即调用，最后一个不会立即调用</p>
<h6 id="事件委托或者事件代理的原理是什么？"><a href="#事件委托或者事件代理的原理是什么？" class="headerlink" title="事件委托或者事件代理的原理是什么？"></a>事件委托或者事件代理的原理是什么？</h6><p>事件冒泡，事件会从目标事件源依次向上冒泡，直到 window 对象</p>
<p>事件捕获，事件从 window 对象依次向下传，直到目标事件源</p>
<h6 id="事件冒泡和事件捕获的区别是什么？"><a href="#事件冒泡和事件捕获的区别是什么？" class="headerlink" title="事件冒泡和事件捕获的区别是什么？"></a>事件冒泡和事件捕获的区别是什么？</h6><p><strong>事件冒泡：</strong>从下至上(是指子元素向父元素传递的过程)，  bool&#x3D;false冒泡(默认)</p>
<p><strong>事件捕获：</strong>从上至下(是指父元素向子元素传递的过程)， bool&#x3D;true 捕获 一般不会用到</p>
<h6 id="你知道的es6新特性有哪些？"><a href="#你知道的es6新特性有哪些？" class="headerlink" title="你知道的es6新特性有哪些？"></a>你知道的es6新特性有哪些？</h6><p>let const 拓展运算符 解构赋值 箭头函数 symbol</p>
<h6 id="js异步编程方式有几种"><a href="#js异步编程方式有几种" class="headerlink" title="js异步编程方式有几种"></a>js异步编程方式有几种</h6><p>AJAX</p>
<p>Promise</p>
<p>async await</p>
<h6 id="promise有几种状态"><a href="#promise有几种状态" class="headerlink" title="promise有几种状态"></a>promise有几种状态</h6><p>pending fulfilled rejected （注意顺序）</p>
<p>​	pending fulfilled rejected   当我们创建一个Promise对象的时候，它的状态默认是pending ,要修改它的状态必须调用resolve方法或者reject方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const myPromiseObj = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">		resolve()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">myPromiseObj.then(()=&gt;&#123;&#125;).catch(()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>



<h6 id="js如何浅拷贝和深拷贝一个对象"><a href="#js如何浅拷贝和深拷贝一个对象" class="headerlink" title="js如何浅拷贝和深拷贝一个对象"></a>js如何浅拷贝和深拷贝一个对象</h6><p>​	浅拷贝：<code>Object.assign 或者拓展运算符...</code></p>
<p>​	深拷贝：<code>const deepCopiedObj = JONS.parse(JSON.stringify(obj))</code></p>
<p>JSON 无法拷贝函数 如何避免？</p>
<p>1.用第三方库提供的现成方法lodash 中的 _cloneDeep（）</p>
<p>2.自己实现深拷贝的方法</p>
<h6 id="rem和em和px的区别"><a href="#rem和em和px的区别" class="headerlink" title="rem和em和px的区别"></a>rem和em和px的区别</h6><p>​	px是固定单位，rem和em是响应式单位，1rem的大小取决于根节点html的字体大小（即font-size属性），1em的大小取决于其父节点的字体大小，在移动端我们一般用rem,但是要注意：这时html的fontSize属性应该是动态计算的，而不是写死，一般是把当前可视窗口的宽度除以一个经验值得到的比值作为html的fontSize属性值的。</p>
<h6 id="for循环中break和continue的区别是什么？"><a href="#for循环中break和continue的区别是什么？" class="headerlink" title="for循环中break和continue的区别是什么？"></a>for循环中break和continue的区别是什么？</h6><p> break：跳出整个循环</p>
<p>continue:跳出档次循环，继续执行后面的循环</p>
<h6 id="如何用原生js给一个按钮的点击事件绑定两个事件处理函数"><a href="#如何用原生js给一个按钮的点击事件绑定两个事件处理函数" class="headerlink" title="如何用原生js给一个按钮的点击事件绑定两个事件处理函数"></a>如何用原生js给一个按钮的点击事件绑定两个事件处理函数</h6><p>​	addEventListener 事件监听器处理</p>
<h6 id="js引擎如何实现异步的？"><a href="#js引擎如何实现异步的？" class="headerlink" title="js引擎如何实现异步的？"></a>js引擎如何实现异步的？</h6><p>​    js引擎是通过事件循环（Event Loop）实现异步的</p>
<p>​    什么是事件循环？？</p>
<p>​      js引擎里面有两个非常重要的部分：执行栈和任务队列</p>
<p>​      所有的代码都要加载到执行栈里面进行执行</p>
<p>​      在执行过程中如果发现有异步任务，则js引擎会把这个异步任务交给浏览器的其他线程去处理，比如在执行的时候遇到</p>
<p>​      接口发送，则js引擎会把它交给http请求线程去处理，然后js引擎继续执行后边的同步任务，但是同http请求线程也在同时</p>
<p>​      运作，当请求发送成功之后，即数据拿到之后，http请求线程会将我们之前在js里面设置的回调函数推送到js引擎的任务队列里面</p>
<p>​      当js引擎在执行栈里面把任务清空之后，则回到任务队列里面去寻找有没有待执行的回调函数，有则拿到执行栈里面去执行</p>
<p>​      执行完了之后，又会到任务队列里面去寻找有没有待执行的回调，如此循环往复的过程就是事件循环，理解了事件循环就理解了</p>
<pre><code>  * 浏览器是多线程的，js引擎只是其中一个线程，除此之外还有http请求线程，定时触发线程，事件处理线程，GUI渲染线程
</code></pre>
<p>​    前置知识：<br>​      1. 浏览器是多线程（一个人，这个人同一个时间只能够做一件事情）的，js引擎只是其中一个线程，专门用来处理js脚本，除此之外<br>​            还有http请求线程，事件触发线程、定时触发线程、GUI渲染引擎（注意该线程和js引擎线程是互斥的，同一个时间只能有一个线程在工作，并且js引擎的优先级一般要高于GUI渲染引擎）<br>​            2. js引擎线程中有两个很重要的概念<br>​                        a. 执行栈（先进后出） ：所有的js脚本都会加载到执行栈中去执行<br>​                        b. 任务队列（先进先出）：存放所有异步任务的回调函数</p>
<p>​      当js引擎在执行栈中执行js脚本的时候，如果发现有异步任务（比如发送http请求），则会把该异步任务交给浏览器的其他线程（http请求线程）去处理<br>​      然后js引擎继续执行后面的同步代码<br>​          此时这里有两条线在同时工作<br>​              1. js引擎继续执行后面的同步任务，当把同步任务执行完成之后，会立刻到任务队里中查找有没有待执行的回调函数<br>​                            如果有 就拿到执行栈中执行，执行完了，又立刻到任务队里中去查找，如此循环往复的过程，就是事件循环（Event Loop）<br>​                            当你理解了事件循环，就相当于理解了js引擎如何实现异步的<br>​                            2. http请求在处理请求、如果请求处理成功，则会把之前设置的回调函数推送到js引擎的任务队列里面</p>
<h6 id="什么是函数柯理化？"><a href="#什么是函数柯理化？" class="headerlink" title="什么是函数柯理化？"></a>什么是函数柯理化？</h6><p>​	通过函数返回函数的方式（闭包），让一个一次性接受多个参数的函数，分解为一次只接受一个参数的若干函数的组合</p>
<p>​	其作用是为了参数的复用，</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function towSum(a,b)&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//现在对上面的函数进行柯理化</span><br><span class="line">function towSum(a)&#123;</span><br><span class="line">	return function(b)&#123;</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">const res = (a)=&gt;(b)=&gt;a+b;</span><br></pre></td></tr></table></figure>



<h6 id="微任务和宏任务的区别"><a href="#微任务和宏任务的区别" class="headerlink" title="微任务和宏任务的区别"></a>微任务和宏任务的区别</h6><p> 微任务常用的只有一个 promise.then</p>
<p> 其他都是宏任务 比如定时器、延时器、发送请求等</p>
<p>​    优先级：微任务优先于宏任务</p>
<h6 id="DOMContentLoaded和load事件的区别"><a href="#DOMContentLoaded和load事件的区别" class="headerlink" title="DOMContentLoaded和load事件的区别"></a>DOMContentLoaded和load事件的区别</h6><p>DOMContentLoaded 意思就是：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p>
<h6 id="防抖和节流有什么区别，如何实现"><a href="#防抖和节流有什么区别，如何实现" class="headerlink" title="防抖和节流有什么区别，如何实现"></a>防抖和节流有什么区别，如何实现</h6><p>​	在高频触发的事件中，可能会导致一些性能问题，比如在PC端浏览器缩放时（resize事件），我们在事件处理函数里面如果操作DOM，则用户缩放的时候，可能会导致浏览器卡顿，这是我们就可以通过防抖节流来控制操作DOM的频率，避免过快的操作DOM，但是这两者的区别在于：</p>
<p>​		防抖的思路是：设置一个延时器，延时n秒在执行相应的逻辑（即频繁执行可能会影响性能的逻辑），如果在n秒内，再次执行了，则清空延时器，并从当下开始从新设置延时器，n秒后再执行。</p>
<p>​		节流的思路是：在特定的时间段内，相应的逻辑必须有且只能执行一次。</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//防抖</span><br><span class="line">function debunce(func,time)&#123;</span><br><span class="line">	let timer = null;</span><br><span class="line">	return function()&#123;</span><br><span class="line">		if(timer)clearInterval(timer);</span><br><span class="line">		timer = setTimeout(()=&gt;&#123;</span><br><span class="line">			func.apply(this,arguments)</span><br><span class="line">		&#125;,time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//节流</span><br><span class="line">function throttle(func,time)&#123;</span><br><span class="line">	let preTime = +new Date()</span><br><span class="line">	return function()&#123;</span><br><span class="line">		const curTime = +new Date()</span><br><span class="line">		if(curTime - preTime &gt;= time)&#123;</span><br><span class="line">			func.apply(this,arguments);</span><br><span class="line">			preTime = curTime;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h6><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = &#123;key:&quot;b&quot;&#125;;</span><br><span class="line">var c = &#123;key:&quot;c&quot;&#125;;</span><br><span class="line">a[b] = &quot;b&quot;;</span><br><span class="line">a[c] = &quot;c&quot;;</span><br><span class="line">console.log(&quot;a[b]&quot;,a[b]);//???</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age = 100;</span><br><span class="line">let years = 6;</span><br><span class="line">if(age &gt; 12)&#123;</span><br><span class="line">    let age = 10;</span><br><span class="line">    var years = age*3;</span><br><span class="line">&#125;</span><br><span class="line">//问：以上代码有问题吗？</span><br></pre></td></tr></table></figure>

<p>3. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">       this.setState(&#123; count: this.state.count + 1 &#125;);</span><br><span class="line">       console.log(&#x27;1&#x27;, this.state.count);</span><br><span class="line">       this.setState(&#123; count: this.state.count + 1 &#125;);</span><br><span class="line">       console.log(&#x27;2&#x27;, this.state.count);</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">           this.setState(&#123; count: this.state.count + 1 &#125;);</span><br><span class="line">           console.log(&#x27;3&#x27;, this.state.count);</span><br><span class="line">           this.setState(&#123; count: this.state.count + 1 &#125;);</span><br><span class="line">           console.log(&#x27;4&#x27;, this.state.count);</span><br><span class="line">       &#125;, 0);</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //打印结果</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>4. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showName();//1</span><br><span class="line">function Cat() &#123;</span><br><span class="line">          let showName = function () &#123;</span><br><span class="line">               console.log(1);</span><br><span class="line">           &#125;</span><br><span class="line">           return this;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">       Cat.showName = function () &#123; console.log(2) &#125;;</span><br><span class="line">       Cat.prototype.showName = function () &#123; console.log(3) &#125;;</span><br><span class="line">       var showName = function () &#123; console.log(4) &#125;;</span><br><span class="line">       function showName() &#123; console.log(5) &#125;;</span><br><span class="line">       Cat.showName();//2</span><br><span class="line">       showName();//3</span><br><span class="line">       Cat().showName();//4</span><br><span class="line">       showName();//4</span><br><span class="line">       new Cat.showName();//5</span><br><span class="line">       new Cat().showName();//6</span><br><span class="line">       new new Cat().showName();//7</span><br><span class="line">       //打印结果？？</span><br></pre></td></tr></table></figure>

<p>5. </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Cat() &#123;</span><br><span class="line">          showName = function () &#123;</span><br><span class="line">               console.log(1);</span><br><span class="line">           &#125;</span><br><span class="line">           console.log(&#x27;this&#x27;,this)</span><br><span class="line">           return this;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">       Cat.showName = function () &#123; console.log(2) &#125;;</span><br><span class="line">       Cat.prototype.showName = function () &#123; console.log(3) &#125;;</span><br><span class="line">       var showName = function () &#123; console.log(4) &#125;;</span><br><span class="line">       function showName() &#123; console.log(5) &#125;;</span><br><span class="line">       Cat.showName();</span><br><span class="line">       showName();</span><br><span class="line">       Cat().showName();</span><br><span class="line">       showName();</span><br><span class="line">       new Cat.showName();</span><br><span class="line">       new Cat().showName();</span><br><span class="line">       new new Cat().showName();</span><br><span class="line">       </span><br><span class="line">       //打印结果，注意跟上一题的区别</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>这段代码有什么问题吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((state,props)=&gt;&#123;</span><br><span class="line">	return &#123;total:state.total + props.count&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看以下代码：如果你在页面中创建了一个React元素，请完成他的组件定义？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Profile username=&quot;sofn&quot;&gt;</span><br><span class="line">	&#123;user=&gt;user===null ? &lt;Loading/&gt; : &lt;Badge info=&#123;user&#125;/&gt;&#125;&#123;&quot; &quot;&#125;</span><br><span class="line">&lt;/Profile&gt;</span><br><span class="line"></span><br><span class="line">import React ,&#123;Component&#125; from &#x27;react&#x27;;</span><br><span class="line">import PropTypes from &#x27;prop-types&#x27;;</span><br><span class="line">import fetchUser from &#x27;utils&#x27;;</span><br><span class="line">//fetchUser接收用户名，并返回promise</span><br><span class="line">//当得到用户数据的时候返回resolve状态</span><br><span class="line">class Profile extends Component&#123;</span><br><span class="line">	//在这里写下你的代码</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h6 id="vue3和vue2的区别"><a href="#vue3和vue2的区别" class="headerlink" title="vue3和vue2的区别"></a>vue3和vue2的区别</h6><h6 id="vue组件中watch和computed的区别"><a href="#vue组件中watch和computed的区别" class="headerlink" title="vue组件中watch和computed的区别"></a>vue组件中watch和computed的区别</h6><pre><code>1. watch中一个值的变化可能会引起多个值的变化，而compouted中多个值的变化会只会影响一个值的变化（即该计算属性返回的值）
2. 在watch中我们可能会有副作用，比如发送请求等，而computed则没有副作用，仅仅是根据母体数据衍生出新的数据而已。
</code></pre>
<h6 id="vue常用的生命周期钩子函数有哪些？分别有什么作用？"><a href="#vue常用的生命周期钩子函数有哪些？分别有什么作用？" class="headerlink" title="vue常用的生命周期钩子函数有哪些？分别有什么作用？"></a>vue常用的生命周期钩子函数有哪些？分别有什么作用？</h6><table>
<thead>
<tr>
<th>钩子函数</th>
<th>created</th>
<th>mounted</th>
<th>updated</th>
<th>beforeDestory</th>
</tr>
</thead>
<tbody><tr>
<td>执行时机</td>
<td>数据初始化完毕之后</td>
<td>DOM渲染完毕之后</td>
<td>数据更新完毕并且DOM更新完毕之后</td>
<td>组件卸载之前</td>
</tr>
<tr>
<td>作用</td>
<td>发送请求</td>
<td>发送请求、获取DOM等</td>
<td>发送请求（注意加上条件判断）、获取DOM等</td>
<td>性能优化相关，比如清除定时器、延时器、解绑事件等</td>
</tr>
</tbody></table>
<h6 id="vue如何实现组件通信（组件传值）？-父子-兄弟-复杂组件关系"><a href="#vue如何实现组件通信（组件传值）？-父子-兄弟-复杂组件关系" class="headerlink" title="vue如何实现组件通信（组件传值）？ 父子  兄弟  复杂组件关系"></a>vue如何实现组件通信（组件传值）？ 父子  兄弟  复杂组件关系</h6><p>​	</p>
<table>
<thead>
<tr>
<th>组件关系</th>
<th>父子</th>
<th>兄弟</th>
<th>复杂组件关系</th>
</tr>
</thead>
<tbody><tr>
<td>通信方式</td>
<td>props&#x2F;绑定自定义事件、$emit</td>
<td>状态提升、事件总线</td>
<td>状态机vuex</td>
</tr>
</tbody></table>
<p>​	</p>
<h6 id="vue项目如何做路由拦截？"><a href="#vue项目如何做路由拦截？" class="headerlink" title="vue项目如何做路由拦截？"></a>vue项目如何做路由拦截？</h6><p>​	全局路由守卫（router.beforeEach）、局部（页面内部）路由守卫</p>
<h6 id="vue的响应式原理-Object-defineProperty"><a href="#vue的响应式原理-Object-defineProperty" class="headerlink" title="vue的响应式原理 Object.defineProperty"></a>vue的响应式原理 Object.defineProperty</h6><p>​	vue组件中data里面的数据，在初始渲染之前都会被Object.defineProperty转化成响应式数据，然后这些数据的访问和修改就能够被监听了，每当数据被访问的时候就会触发getter,接着会通知watcher，watcher这是会做一次依赖的收集或者更新，然后watcher会负责通知渲染界面（先转化为虚拟DOM,在映射为真正的DOM）。每当数据被设置的时候会触发setter,接着setter也会通知watcher,watcher在去通知渲染界面</p>
<h6 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h6><h6 id="v-if和v-for能一起用吗"><a href="#v-if和v-for能一起用吗" class="headerlink" title="v-if和v-for能一起用吗"></a>v-if和v-for能一起用吗</h6><h6 id="keep-alive组件有什么作用"><a href="#keep-alive组件有什么作用" class="headerlink" title="keep-alive组件有什么作用"></a>keep-alive组件有什么作用</h6><p>​	缓存组件</p>
<h6 id="this-nextTick有什么作用"><a href="#this-nextTick有什么作用" class="headerlink" title="this.$nextTick有什么作用"></a>this.$nextTick有什么作用</h6><p>类似updated,你可以称作移动版的updated,如果你想获取数据更新过后，DOM的最新状态，则可以使用该方法（如果你直接获取DOM状态是拿不到的，因为在vue里面数据更新虽然是同步的，但是DOM的更新是异步的），当然你也可以利用updated生命周期钩子函数，但是不方便</p>
<h6 id="this-set有什么作用"><a href="#this-set有什么作用" class="headerlink" title="this.$set有什么作用"></a>this.$set有什么作用</h6><p>​	在组件data中预定义的数据，一定是响应式的，但是我们后续，通过常规的方式（比如someObject.propName &#x3D; xxx）为data中某些对象添加新的属性时，这些新的属性并不是响应式的，这是可以使用该方法。 this.$set(target,prop,value)  这里的prop属性就是响应式的</p>
<h6 id="vuex核心概念"><a href="#vuex核心概念" class="headerlink" title="vuex核心概念"></a>vuex核心概念</h6><h6 id="vue如何做路由懒加载"><a href="#vue如何做路由懒加载" class="headerlink" title="vue如何做路由懒加载"></a>vue如何做路由懒加载</h6><p>​	路由配置中component属性的值修改为：（）&#x3D;&gt;import(组件路径)</p>
<h6 id="你认为vue-框架和jquery有什么区别？"><a href="#你认为vue-框架和jquery有什么区别？" class="headerlink" title="你认为vue 框架和jquery有什么区别？"></a>你认为vue 框架和jquery有什么区别？</h6><p>开发思想不同，vue是数据驱动，并且可以组件化开发，jquery则是DOM驱动的，开发效率低</p>
<h6 id="vue如何自定义指令"><a href="#vue如何自定义指令" class="headerlink" title="vue如何自定义指令"></a>vue如何自定义指令</h6><h6 id="如何封装一个vue插件"><a href="#如何封装一个vue插件" class="headerlink" title="如何封装一个vue插件"></a>如何封装一个vue插件</h6><h6 id="vue中什么是过滤器（filter）"><a href="#vue中什么是过滤器（filter）" class="headerlink" title="vue中什么是过滤器（filter）"></a>vue中什么是过滤器（filter）</h6><h6 id="vue如何提取组件的公共逻辑"><a href="#vue如何提取组件的公共逻辑" class="headerlink" title="vue如何提取组件的公共逻辑"></a>vue如何提取组件的公共逻辑</h6><p>​	vuex&#x2F;mixins&#x2F;自定义指令&#x2F;插件</p>
<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h6 id="shouldComponentUpdate有什么作用？"><a href="#shouldComponentUpdate有什么作用？" class="headerlink" title="shouldComponentUpdate有什么作用？"></a>shouldComponentUpdate有什么作用？</h6><p>​	它是react组件的一个 生命周期钩子函数，每次数据更新时，首先会执行该钩子函数，如果返回true,表示可以更新界面，然后后续的钩子函数才会陆续执行，返回false，则表示不可以更新，后续的钩子函数也不会执行，当然它默认返回true,</p>
<p>​	我们一般不会直接在组件中使用该钩子函数，而是会选择PureCompopnent来代替Component,在PureComponent里面就利用来该钩子函数来做优化</p>
<h6 id="setState有什么特性"><a href="#setState有什么特性" class="headerlink" title="setState有什么特性"></a>setState有什么特性</h6><p>​		它的作用是更新组件内部状态，可以接受两个参数，参数一个一般是个对象，在底层react会通过Object.assign把传入的对象和原来的state进行合并，当然也可以传入一个函数，这个函数会接受两个形参（一个表示state，一个表示props）,并返回个对象，要注意的是，这个函数在执行是会保证之前的state已经更新完毕，最后在把该函数返回的对象和原来的对象进行合并。当新的状态值会基于老的状态值时，我们会倾向于给setState的第一个参数传递一个函数进去。它的第二个参数则是一个回调函数，会在数据更新完毕，并且dom更新完毕时执行。</p>
<p>​		另外，当我们在react事件体系或者组件生命周期钩子函数里面直接调用setState的时候，它是异步的，其他情况是同步的，比如在setTimeout&#x2F;setInterval里面调用就是同步的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;name:&#x27;张三&#x27;&#125;);</span><br><span class="line">this.setState((state,props)=&gt;(&#123;&#125;)</span><br></pre></td></tr></table></figure>



<h6 id="react列表渲染时，key的作用"><a href="#react列表渲染时，key的作用" class="headerlink" title="react列表渲染时，key的作用"></a>react列表渲染时，key的作用</h6><p>​	提升渲染性能</p>
<h6 id="react组件之间如何通信"><a href="#react组件之间如何通信" class="headerlink" title="react组件之间如何通信"></a>react组件之间如何通信</h6><p>​	父子（props）、兄弟(状态提升、事件总线)、复杂组件关系（状态机）</p>
<h6 id="解释一下redux核心概念"><a href="#解释一下redux核心概念" class="headerlink" title="解释一下redux核心概念"></a>解释一下redux核心概念</h6><p>​	store action reducer</p>
<h6 id="react常用的生命周期钩子函数有哪些？分别有什么作用"><a href="#react常用的生命周期钩子函数有哪些？分别有什么作用" class="headerlink" title="react常用的生命周期钩子函数有哪些？分别有什么作用"></a>react常用的生命周期钩子函数有哪些？分别有什么作用</h6><table>
<thead>
<tr>
<th>钩子函数名</th>
<th>constructor</th>
<th>render</th>
<th>componentDidMount</th>
<th>componentDidUpdate</th>
<th>componentWillUnmount</th>
</tr>
</thead>
<tbody><tr>
<td>执行时机和作用</td>
<td>组件初始化时负责数据的初始化</td>
<td>渲染界面</td>
<td>DOM渲染完毕时执行，可以在这里发送接口，获取DOM等</td>
<td>数据更新完毕且界面更新完毕后执行</td>
<td>组件即将卸载的时候执行，可以在这里清除定时器，延时器，解绑事件等等</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="react中refs有什么作用？"><a href="#react中refs有什么作用？" class="headerlink" title="react中refs有什么作用？"></a>react中refs有什么作用？</h6><pre><code>1. 获取DOM
2. 获取组件实例
</code></pre>
<h6 id="redux中间件是什么，有什么作用，你常用的中间件有哪些？"><a href="#redux中间件是什么，有什么作用，你常用的中间件有哪些？" class="headerlink" title="redux中间件是什么，有什么作用，你常用的中间件有哪些？"></a>redux中间件是什么，有什么作用，你常用的中间件有哪些？</h6><h6 id="redux三大原则是什么？"><a href="#redux三大原则是什么？" class="headerlink" title="redux三大原则是什么？"></a>redux三大原则是什么？</h6><ol>
<li>单一数据源</li>
<li>store中的数据（state）是只读的</li>
<li>必须通过纯函数reducer来执行修改</li>
</ol>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h6 id="react中容器组件和展示组件有什么区别？"><a href="#react中容器组件和展示组件有什么区别？" class="headerlink" title="react中容器组件和展示组件有什么区别？"></a>react中容器组件和展示组件有什么区别？</h6><h6 id="函数组件和类组件有什么区别（16-8以前）？"><a href="#函数组件和类组件有什么区别（16-8以前）？" class="headerlink" title="函数组件和类组件有什么区别（16.8以前）？"></a>函数组件和类组件有什么区别（16.8以前）？</h6><h6 id="你对react新特性hooks有什么了解吗？"><a href="#你对react新特性hooks有什么了解吗？" class="headerlink" title="你对react新特性hooks有什么了解吗？"></a>你对react新特性hooks有什么了解吗？</h6><h6 id="react如何提取组件之间的公共逻辑"><a href="#react如何提取组件之间的公共逻辑" class="headerlink" title="react如何提取组件之间的公共逻辑"></a>react如何提取组件之间的公共逻辑</h6><h6 id="什么是高阶组件？有什么作用？你常用的高阶组件有哪些"><a href="#什么是高阶组件？有什么作用？你常用的高阶组件有哪些" class="headerlink" title="什么是高阶组件？有什么作用？你常用的高阶组件有哪些"></a>什么是高阶组件？有什么作用？你常用的高阶组件有哪些</h6><h6 id="受控组件和不受控组件有什么区别？"><a href="#受控组件和不受控组件有什么区别？" class="headerlink" title="受控组件和不受控组件有什么区别？"></a>受控组件和不受控组件有什么区别？</h6><h6 id="JSX的底层原理是什么？"><a href="#JSX的底层原理是什么？" class="headerlink" title="JSX的底层原理是什么？"></a>JSX的底层原理是什么？</h6><h6 id="react组件的数据来源有哪些？他们之间有什么区别？"><a href="#react组件的数据来源有哪些？他们之间有什么区别？" class="headerlink" title="react组件的数据来源有哪些？他们之间有什么区别？"></a>react组件的数据来源有哪些？他们之间有什么区别？</h6><h6 id="react插槽是什么？（或者react中如何实现组件复合？）"><a href="#react插槽是什么？（或者react中如何实现组件复合？）" class="headerlink" title="react插槽是什么？（或者react中如何实现组件复合？）"></a>react插槽是什么？（或者react中如何实现组件复合？）</h6><h6 id="react中context是什么？"><a href="#react中context是什么？" class="headerlink" title="react中context是什么？"></a>react中context是什么？</h6><h6 id="react中废弃了哪些和新增了哪些生命周期钩子函数"><a href="#react中废弃了哪些和新增了哪些生命周期钩子函数" class="headerlink" title="react中废弃了哪些和新增了哪些生命周期钩子函数"></a>react中废弃了哪些和新增了哪些生命周期钩子函数</h6><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h6 id="小程序一个页面有几个文件构成？"><a href="#小程序一个页面有几个文件构成？" class="headerlink" title="小程序一个页面有几个文件构成？"></a>小程序一个页面有几个文件构成？</h6><h6 id="小程序怎么跟后台交互"><a href="#小程序怎么跟后台交互" class="headerlink" title="小程序怎么跟后台交互"></a>小程序怎么跟后台交互</h6><p>（1）直接用微信官方提供的接口 wx.request接口，跟jquery的ajax差不多</p>
<h6 id="小程序怎么做扫码功能（wx-scanCode），怎么做支付功能-wx-requestPayment"><a href="#小程序怎么做扫码功能（wx-scanCode），怎么做支付功能-wx-requestPayment" class="headerlink" title="小程序怎么做扫码功能（wx.scanCode），怎么做支付功能(wx.requestPayment)"></a>小程序怎么做扫码功能（wx.scanCode），怎么做支付功能(wx.requestPayment)</h6><p>（1）调用微信提供的现成的接口（wx.开头的），即可，具体参数怎么传参照文档即可</p>
<h6 id="微信里面怎么获取用户的手机号？？"><a href="#微信里面怎么获取用户的手机号？？" class="headerlink" title="微信里面怎么获取用户的手机号？？"></a>微信里面怎么获取用户的手机号？？</h6><p>（1）简单，直接用微信官方提供的现成组件button即可，具体用法是在button上加一个属性opent-type，方它的值为getPhoneNumber,不知道怎么用的去找微信官文档看看、</p>
<h6 id="小程序分包是什么？有什么作用？"><a href="#小程序分包是什么？有什么作用？" class="headerlink" title="小程序分包是什么？有什么作用？"></a>小程序分包是什么？有什么作用？</h6><p>提示：跟vue路由懒加载有类似的作用，提升用户体验度，减少首屏渲染速度</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html">https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/acmdown/article/details/80037660">https://blog.csdn.net/acmdown/article/details/80037660</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h5 id="从用户在浏览器中输入url-到浏览器渲染出界面，中间发生了什么？"><a href="#从用户在浏览器中输入url-到浏览器渲染出界面，中间发生了什么？" class="headerlink" title="从用户在浏览器中输入url,到浏览器渲染出界面，中间发生了什么？"></a>从用户在浏览器中输入url,到浏览器渲染出界面，中间发生了什么？</h5><p>​	DNS域名解析——》发起http或者https请求——》服务端处理请求——-》浏览器接受请求响应，并渲染界面</p>
<h5 id="SPA（single-page-application）如何提高首屏（注意：不是首页，一般你在url中输入一个新的路劲，然后回车，即是一个首屏）的渲染速度"><a href="#SPA（single-page-application）如何提高首屏（注意：不是首页，一般你在url中输入一个新的路劲，然后回车，即是一个首屏）的渲染速度" class="headerlink" title="SPA（single page application）如何提高首屏（注意：不是首页，一般你在url中输入一个新的路劲，然后回车，即是一个首屏）的渲染速度"></a>SPA（single page application）如何提高首屏（注意：不是首页，一般你在url中输入一个新的路劲，然后回车，即是一个首屏）的渲染速度</h5><h6 id="DNS域名解析部分优化"><a href="#DNS域名解析部分优化" class="headerlink" title="DNS域名解析部分优化"></a>DNS域名解析部分优化</h6><ol>
<li>DNS prefetch(DNS预解析)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在html头部使用link标签进行DNS预解析</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.baidu.com&quot;&gt;</span><br></pre></td></tr></table></figure>

<h6 id="发起请求部分"><a href="#发起请求部分" class="headerlink" title="发起请求部分"></a>发起请求部分</h6><ol>
<li><p>减少请求次数</p>
<ol>
<li><p>采用css sprinte(也叫雪碧图或者精灵图)，即：如果有多张比较小的背景图，可以合成一个，然后通过background-position去设置背景，而不用每个都去发送请求</p>
</li>
<li><p>某些图片编译成可以是用base64格式（webpack中的url-loader会自动把大小小于某些值的图片编译成base64格式的，然后内嵌到js文件中，所以后续在访问这些图片时，不在需要单独发送请求）</p>
<ul>
<li><p>何时用base64格式的图片？？，可以参考以下几个因素</p>
<ol>
<li><p>这类图片不能与其他图片以CSS Sprite的形式存在，只能独行</p>
</li>
<li><p>这类图片从诞生之日起，基本上很少被更新</p>
</li>
<li><p>这类图片的实际尺寸很小</p>
</li>
<li><p>这类图片在网站中大规模使用</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>合并脚本和样式表，但是要视情况而定，如果合并脚本或者样式表后，包的体积变得非常大，反而会过度延长网络请求时间，从而导致首先渲染更慢</p>
</li>
<li><p>利用http缓存（新鲜度限值和服务器在验证）</p>
</li>
</ol>
</li>
<li><p>减少请求或者服务端响应式时（当然主要是响应），网络数据包的大小</p>
<ol>
<li>压缩css&#x2F;js、图片等</li>
<li>路由懒加载</li>
</ol>
</li>
<li><p>缩短网络的传输距离，优化网络传输路径</p>
<ol>
<li>利用CDN（内容分发网络），一般我们会把静态资源，即很少变化，体积有比较大的资源交给CDN服务商管理</li>
</ol>
</li>
</ol>
<h6 id="服务端优化：不需要关注"><a href="#服务端优化：不需要关注" class="headerlink" title="服务端优化：不需要关注"></a>服务端优化：不需要关注</h6><p>​	使用单独的图片服务器、使用redis缓存、使用负载均衡等等</p>
<h6 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h6><ol>
<li><p>css放在body之前，script放在body之后</p>
</li>
<li><p>ssr(server side render—服务端渲染)</p>
</li>
<li><p>requestAnimationFrame</p>
<p>对于动画来讲：定时器为什么不是一个好的方案</p>
<p>​       1. 开发人员并不知道，间隔多少时间出发一个动画何时，间隔时间如果太短，则会损耗浏览器的性能，如果间隔时间太长,则用户就会感觉卡顿。并且定时器自身机制的问题，它的回调函数触发的时机可能并不是你设置的时间，因为他要等到执行栈里面的任务清空之后再去执行</p>
<pre><code>     优化要达到的目的：间隔时间合适，同时用户不会觉得卡
</code></pre>
<p>​       分析：</p>
<p>​         第一：间隔时间要合适，你自己手动设置肯定不行，因为延时器或定时器触发的时机本就不精确。</p>
<p>​         第二：用户不会觉得卡顿，首先我们要搞清楚是什么原因导致的卡顿，所以接下来，我们要解释一下浏览器<strong>帧</strong>的概念</p>
<p>​           	帧：浏览器中的页面是有一帧一帧绘制出来的，当每秒钟绘制的帧数（FPS–Frame Per Second）大于或等于60的时候，用户是感觉不到卡顿的，换言每一帧的时间控制在1s&#x2F;60,也就是大约16.6毫秒之内时，用户是感觉不到卡顿的。</p>
<p>​           <strong>在一帧中浏览器大致做了如下事情（有时不一定每一步都会执行）：</strong></p>
<p>​             1. 处理用户的交互</p>
<p>​             2. js解析执行（例如用户事件处理函数中的逻辑）</p>
<p>​             3. 调用window.requestAnimationFrame中注册的函数（<strong>注意：这个函数其实是上一帧中注册的函数，且如果在这一帧中发现有注册的函数，则该函数一定会被执行</strong>）</p>
<p>​             4. Layout（布局，如果第二次触发，我们就称之为回流）</p>
<p>​             5. Paint（绘制，如果第二次触发我们就称之为重绘）</p>
<p>​             6. <strong>如果前五步骤执行完了之后，这一帧还有剩余时间</strong>，则调用window.requestIdleCallback中注册的函数</p>
<p>​           也就是说这前五个步骤（其他我们先暂时不用考虑）执行时间总和要在16.6毫秒内，才能保证用户体验。</p>
<p>​	结论：我们可以利用requestAnimationFrame实现动画逻辑，并且不需要传递时间，在这里触发动画，一般情况1秒钟也能达到60帧（当然动画里的逻辑也不能太复杂，在这一步，如果执行时间过长也会导致掉帧（1秒钟没有达到60次），从而让用户决定卡顿），具体用法如下（实现一个元素，在水平方向上左右移动的效果）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:50px;height:50px;background-color: red;&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> let originStep  = 10;   </span><br><span class="line"> let step = 10;//每次移动的距离</span><br><span class="line"> let direction = 1;//移动的方向1表示向右，-1表示向左</span><br><span class="line"> let left = 0;//元素的偏移量</span><br><span class="line"> const offsetWidth = document.body.offsetWidth;//body的宽度</span><br><span class="line"> const el = document.getElementById(&#x27;myDiv&#x27;);</span><br><span class="line"> const eleWidth = el.offsetWidth;//元素的宽度</span><br><span class="line"> const runAnimation = () =&gt; &#123;</span><br><span class="line">     if(direction === 1)&#123;</span><br><span class="line">     	const remainOffset = offsetWidth - (left + eleWidth);//向右移动时，距离右边距剩余距离</span><br><span class="line">     if(remainOffset &lt; step &amp;&amp; remainOffset !== 0)&#123;</span><br><span class="line">     	step = remainOffset;//保证向右的移动不会超出右边接线</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">     	step = originStep;//当向左移动的时候恢复移动速度</span><br><span class="line">     &#125;</span><br><span class="line">     if(left &lt;=0)&#123;</span><br><span class="line">     	direction = 1;</span><br><span class="line">     &#125;else if(offsetWidth &lt;= left + eleWidth)&#123;</span><br><span class="line">     	direction = -1;</span><br><span class="line">     &#125;</span><br><span class="line">     const xOffset = left += step*direction;</span><br><span class="line">     el.style.transform = `translate($&#123;xOffset&#125;px,0)`;</span><br><span class="line">     requestAnimationFrame(runAnimation);//在注册回调</span><br><span class="line">  &#125;</span><br><span class="line">  requestAnimationFrame(runAnimation)</span><br></pre></td></tr></table></figure>

<p>​	</p>
<ul>
<li><p>requestAnimationFrame执行过后会返回一个id,跟定时器一样，我们可以根据这个id取消对应的requestAnimationFrame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cancelId = requestAnimationFrame(runAnimation);</span><br><span class="line">cancelAnimationFrame(cancelId);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​       </p>
</li>
<li><p>requestIdleCallback</p>
</li>
</ol>
<h3 id="SSR-Server-Side-Render-和CSR-Client-Side-Render"><a href="#SSR-Server-Side-Render-和CSR-Client-Side-Render" class="headerlink" title="SSR(Server Side Render)和CSR(Client Side Render)"></a>SSR(Server Side Render)和CSR(Client Side Render)</h3><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>​	浏览器中显示的页面，是由服务器拼接好模板，然后通过网络传送到浏览器，在有浏览器直接渲染的，由于在网络传输路径中携带了网页的内容，所以ssr模式非常适合做SEO，同时服务器拼装模板的速度会比浏览器快很多，所以SSR模式也会提升网站的首屏渲染速度。但是也会增加服务端的压力。</p>
<p>ssr两个优势</p>
<p>​	利于seo</p>
<p>​	缩短首屏渲染速度</p>
<h4 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h4><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h6 id="webpack有什么作用？"><a href="#webpack有什么作用？" class="headerlink" title="webpack有什么作用？"></a>webpack有什么作用？</h6><p>   什么是webpack ? 模块化的打包工具，原理是，我们必须向它提供一个入口js文件，然后webpack会根据这个入口文件生成一张依赖图，然后在堆这张依赖图里面的文件进行转义和打包，最后生成浏览器能够识别的资源文件（css  js 。。。）</p>
<p>作用：</p>
<pre><code>1. 让项目模块化
2. 编译scss/less  .vue   jsx 
3. 性能优化：压缩、代码拆分、图片转base64格式。。。
4. 工程化：自动编译、打包
</code></pre>
<h6 id="webpack常用配置项有哪些？（webpack-config-js）"><a href="#webpack常用配置项有哪些？（webpack-config-js）" class="headerlink" title="webpack常用配置项有哪些？（webpack.config.js）"></a>webpack常用配置项有哪些？（webpack.config.js）</h6><ol>
<li><p>entry:入口文件</p>
</li>
<li><p>output:出口文件</p>
</li>
<li><p>module</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">rules:[</span><br><span class="line">	&#123;</span><br><span class="line">			test:/\.css$/,</span><br><span class="line">			use:[&#x27;style-loader&#x27;，&#x27;css-loader&#x27;],//从后往前执行</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	</p>
<h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><h6 id="常用的http状态码有哪些，"><a href="#常用的http状态码有哪些，" class="headerlink" title="常用的http状态码有哪些，"></a>常用的http状态码有哪些，</h6><pre><code>1. 200 
2. 404 
3. 401  
4. 500
5. 304  
6. 301 资源永久重定向
</code></pre>
<h6 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h6><p> 安全：https协议在传输数据的时候，会对数据进行加密()，http则是明文传输</p>
<p>性能：http协议的传输性能更高，因为对于传输同样的数据量来讲，由于https协议需要加密处理，所以最终在线路上它的数据量要大一点</p>
<p>费用：https需要购买证书，http则免费</p>
<p>默认端口不同：https–443   http—80</p>
<h6 id="websokect和http的区别"><a href="#websokect和http的区别" class="headerlink" title="websokect和http的区别"></a>websokect和http的区别</h6><p> websokect能够实现客户端和服务端的双向通信，http则只能是单向通信，由客户端去请求服务端，服务端不能主动的向客户端推送数据</p>
<p>应用场景不同</p>
<p>​	websokect  实时通信   数据的实时更新 </p>
<p>http  简单的客户端请求服务端</p>
<h3 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h3><h6 id="如何处理权限问题"><a href="#如何处理权限问题" class="headerlink" title="如何处理权限问题"></a>如何处理权限问题</h6><p>比如后台管理系统，不同的角色看到的侧边栏项是不同的，如何实现？</p>
<p>首先把侧边栏抽象成一个数组，数组里面每一元素（对象）则表示每一个侧边栏，并且在每一个元素里面，我们需要添加一个表示角色的字典，以此来区分，何种角色能够看到当前侧边栏项，</p>
<p>接线来，就要根据当前登录人的角色 去 过滤当前数组，并返回当前角色能看到的侧边栏数据</p>
<p>最后在根据得到的数据，进行遍历循环，渲染侧边栏</p>
<h6 id="前端如何实现身份验证"><a href="#前端如何实现身份验证" class="headerlink" title="前端如何实现身份验证"></a>前端如何实现身份验证</h6><ol>
<li>session  早些年在token出现之前都是通过session来实现浏览器客户端的身份验证的，每次用户登录时把用户名和密码传到后端服务器，后端服务器验证用户名和密码，如果验证通过就会生成一个sessionId，并存储到服务器中，同时该请求在响应给客户端时，会通过<code>Set-Cookie</code>字段把sessionId投放并存储到客户端(浏览器)的<code>HTTP-cookies</code>，当客户端下一次发送请求到服务端的时候会自动携带上存有sessionId的cookie。这样后端服务器拿到sessionId和之前存储的sessionId一对比，如果一样就确定该用户是之前的用户，然后就把数据响应到客户端了。</li>
<li>token	每次用户登录时把用户名和密码传到后端服务器，后端服务器验证用户名和密码，如果验证通过一般会用过<code>JWT</code>结合用户信息通过一个秘钥（该秘钥会存储到服务器）加密生成一个token，然后把该token返回给客户端，客户端一般把token存储到本地存储，比如<code>localStorage</code>或者<code>sessionStorage</code>中。后续在在发送接口的时候会把token从本地存储中取出来，放到请求头<code>Header</code>中发送给后端服务器。后端拿到token，然后通过之前的秘钥尝试去解该token，如果能解密出来就说明该token是合法的，否则就是不合法的。</li>
<li>session和token的区别<ol>
<li>session需要借助于cookie，而cookie只有浏览器支持，如果要做app则没办法用session来实现身份验证。只能用token</li>
<li>seesion需要在服务器中存储每位用户对应的sessionId,而token只需要存一份秘钥即可。</li>
</ol>
</li>
</ol>
<h6 id="数据可视化如何实现（echart）"><a href="#数据可视化如何实现（echart）" class="headerlink" title="数据可视化如何实现（echart）"></a>数据可视化如何实现（echart）</h6><p> option       setOption(option)</p>
<p>如何实现数据的实时更新    websocket   </p>
<h6 id="在项目中如何做到token的无感刷新"><a href="#在项目中如何做到token的无感刷新" class="headerlink" title="在项目中如何做到token的无感刷新"></a>在项目中如何做到token的无感刷新</h6><h6 id="uni-app中要路径跳转，如何提高效率"><a href="#uni-app中要路径跳转，如何提高效率" class="headerlink" title="uni-app中要路径跳转，如何提高效率"></a>uni-app中要路径跳转，如何提高效率</h6><p>​	使用uni.preloadPage页面预加载,但是该方法有兼容性问题，只在app端和H5端有效</p>
<h6 id="请说一下你项目中微信支付流程如何做的"><a href="#请说一下你项目中微信支付流程如何做的" class="headerlink" title="请说一下你项目中微信支付流程如何做的"></a>请说一下你项目中微信支付流程如何做的</h6><h6 id="说一下项目中微信授权登录的流程。前后端是如何去交互的"><a href="#说一下项目中微信授权登录的流程。前后端是如何去交互的" class="headerlink" title="说一下项目中微信授权登录的流程。前后端是如何去交互的"></a>说一下项目中微信授权登录的流程。前后端是如何去交互的</h6><p>​	参照：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p>
<h6 id="项目中权限如何如何渲染，如果后端的权限粒度要控制到每个功能如何实现"><a href="#项目中权限如何如何渲染，如果后端的权限粒度要控制到每个功能如何实现" class="headerlink" title="项目中权限如何如何渲染，如果后端的权限粒度要控制到每个功能如何实现"></a>项目中权限如何如何渲染，如果后端的权限粒度要控制到每个功能如何实现</h6><h6 id="为什么使用uni-app，你在项目开发的过程中遇到哪些兼容问题，以及如何处理的"><a href="#为什么使用uni-app，你在项目开发的过程中遇到哪些兼容问题，以及如何处理的" class="headerlink" title="为什么使用uni-app，你在项目开发的过程中遇到哪些兼容问题，以及如何处理的"></a>为什么使用uni-app，你在项目开发的过程中遇到哪些兼容问题，以及如何处理的</h6><ol>
<li>页面预加载，只有H5和APP端支持，小程序不支持</li>
<li>css中给元素设置背景图，H5端支持，小程序不支持（在小程序端用行内样式设置背景图即可）</li>
<li>css中通配符*在H5端支持，但是小程序不支持</li>
<li>在非H5端不能使用ref的方式引用内置组件（比如view等）<ul>
<li>如果想为不同的平台写不同的代码，可以使用条件编译</li>
</ul>
</li>
</ol>
<h6 id="项目中遇到的最大的问题是什么"><a href="#项目中遇到的最大的问题是什么" class="headerlink" title="项目中遇到的最大的问题是什么"></a>项目中遇到的最大的问题是什么</h6><h6 id="在页面中如果要同时发送5个接口，当所有接口都成功相应之后，再去做其他操作，这个如何实现"><a href="#在页面中如果要同时发送5个接口，当所有接口都成功相应之后，再去做其他操作，这个如何实现" class="headerlink" title="在页面中如果要同时发送5个接口，当所有接口都成功相应之后，再去做其他操作，这个如何实现"></a>在页面中如果要同时发送5个接口，当所有接口都成功相应之后，再去做其他操作，这个如何实现</h6><p>​	promise.all同时注意与promise.allSettled做对比</p>
<h6 id="项目是如何打包上线的，打包的时候需要配置些什么内容"><a href="#项目是如何打包上线的，打包的时候需要配置些什么内容" class="headerlink" title="项目是如何打包上线的，打包的时候需要配置些什么内容"></a>项目是如何打包上线的，打包的时候需要配置些什么内容</h6><h6 id="项目中如何实现上拉加载，下拉刷新的，如果要自己实现，说一下思路"><a href="#项目中如何实现上拉加载，下拉刷新的，如果要自己实现，说一下思路" class="headerlink" title="项目中如何实现上拉加载，下拉刷新的，如果要自己实现，说一下思路"></a>项目中如何实现上拉加载，下拉刷新的，如果要自己实现，说一下思路</h6><h6 id="前端登录后，传递id给后端获取数据，这种方式安全吗？你是如何来避免的"><a href="#前端登录后，传递id给后端获取数据，这种方式安全吗？你是如何来避免的" class="headerlink" title="前端登录后，传递id给后端获取数据，这种方式安全吗？你是如何来避免的"></a>前端登录后，传递id给后端获取数据，这种方式安全吗？你是如何来避免的</h6><pre><code>1. 把get方式换成POST
2. 如果我用抓包工具，把数据抓下来，在伪装发送接口，怎么办？-----http--&gt;https
</code></pre>
<h6 id="项目如何打包为apk，如果是ios系统，如何打包呢"><a href="#项目如何打包为apk，如果是ios系统，如何打包呢" class="headerlink" title="项目如何打包为apk，如果是ios系统，如何打包呢"></a>项目如何打包为apk，如果是ios系统，如何打包呢</h6><h6 id="团队中各个成员是如何配合的"><a href="#团队中各个成员是如何配合的" class="headerlink" title="团队中各个成员是如何配合的"></a>团队中各个成员是如何配合的</h6><h6 id="微信小程序如何发布上线"><a href="#微信小程序如何发布上线" class="headerlink" title="微信小程序如何发布上线"></a>微信小程序如何发布上线</h6><p><img src="C:\Users\LXT\AppData\Roaming\Typora\typora-user-images\image-20201214170357300.png" alt="image-20201214170357300"></p>
<p>微信小程序上线发布，通过有上角的上传按钮即可哈，上传后，微信官方会做一个审核，审核通过之后，我们就能够通过微信搜索到该小程序了</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h6 id="什么是跨域？如何解决"><a href="#什么是跨域？如何解决" class="headerlink" title="什么是跨域？如何解决"></a>什么是跨域？如何解决</h6><p>跨域是浏览器的同源策略导致的问题，当我们的协议、域名和端口号，任意一个不同的时候，就会导致跨域的出现</p>
<p>常见的一个场景，前端请求后端api的时候出现跨域，如何解决？</p>
<ol>
<li><p>前端处理：代理服务器  webpack-dev-server   (vue.config.js)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">	proxy:&#123;</span><br><span class="line">		&quot;/api&quot;:&#123;</span><br><span class="line">			target:&quot;http://localhost:8000&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后端处理</p>
<ol>
<li>设置响应头</li>
</ol>
</li>
</ol>
<h6 id="浏览器渲染页面的流程"><a href="#浏览器渲染页面的流程" class="headerlink" title="浏览器渲染页面的流程"></a>浏览器渲染页面的流程</h6><p>​	GUI渲染线程负责界面的渲染过程</p>
<p>​	同时解析html&#x2F;css</p>
<p>解析html   —-&gt;DOMTree</p>
<p>解析css—&gt;CSSTree</p>
<p>然后合并DOMTree和CSSTree形成RenderTree(渲染树)</p>
<p>接下来开始layout  (布局，回流)</p>
<p>绘制（重绘）</p>
<p>根据这些过程我们可以知晓在写html的时候需要注意的一些事项（性能优化）</p>
<pre><code>1. css放在头部
2. js放在尾部，因为js是有js引擎去编译和执行的，而js引擎和GUI渲染引擎是互斥的
</code></pre>
<h6 id="重绘和回流有什么区别"><a href="#重绘和回流有什么区别" class="headerlink" title="重绘和回流有什么区别"></a>重绘和回流有什么区别</h6><h2 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h2><h6 id="你知道的数据结构有哪些？"><a href="#你知道的数据结构有哪些？" class="headerlink" title="你知道的数据结构有哪些？"></a>你知道的数据结构有哪些？</h6><p>栈、队列、链表、二叉树</p>
<h6 id="空间复杂度和时间复杂度"><a href="#空间复杂度和时间复杂度" class="headerlink" title="空间复杂度和时间复杂度"></a>空间复杂度和时间复杂度</h6><p>这个两个概念是用来衡量一个算法优劣的两个维度，空间复杂度表示，算法所消耗的内存大小，而时间复杂度，表示一个算法所消耗的时间。一般情况下，我们更看重一个算法在时间上的消耗。如果时间太长，则认为这个算法是不太好的需要优化，所以才会有用空间换时间这个说法。</p>
<p>时间复杂度可以用大O表示法。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-11-11</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/11/11/mianshi/,Steve Gao's 自留地,mianshi,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/11/11/hello-world/" title="Hello World">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>